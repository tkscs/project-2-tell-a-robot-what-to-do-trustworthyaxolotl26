For your perfect circle function:
What if you try turning right a big amount that's approximately how long it takes to turn 360, then see if your sonar readings suggest you should turn right or left to get to the original sonar readings. Then spin that direction by small amounts, until you overshoot. Then go the other direction by even smaller amounts until you overshoot. Then go the opposite direction by EVEN SMALLER amounts. Pick how close you want to be when you stop. (It's impossible to get the exact same amount as before, but you can get within a couple decimal points, which is pretty good!)

Overall Rough Draft Score: 50 / 50
 
Basic Functionality (15 points):

* [ 10 / 10 ] Robot can move, and code runs without errors in simulator
* [ 2 / 5 ] Robot does not crash into walls
    * if we spiral, then spiral again, robot crashes

Control Flow - If/Elif/Else (15 points):

* [ 5 / 5 ] At least one if/elif/else chain with 3+ branches
* [ 5 / 5 ] At least one if/else that checks a sonar sensor reading
    * You have a couple `while` loops that do this: also good.
* [ 5 / 5 ] At least one if/else that checks user input

User Input (15 points):

* [ 3 / 3 ] At least 3 different input() prompts
* [ 6 / 6 ] At least 6 different user responses are handled (2 per prompt above)
* [ 6 / 6 ] Robot behavior changes based on user input at least 6 times (each response above corresponds to a different behavior)

Functions (10 points):

* [ 3 / 3 ] Define at least 3 functions
* [ 3 / 3 ] Call each of your functions at least once
* [ 2 / 3 ] For each function, include a doc string explaining the API
* [ 1 / 1 ] At least 1 of your functions has at least 1 parameter

Sensors (10 points):

* [ 5 / 5 ] Read a sonar distance at least 5 times
* [ 5 / 5 ] Robot behavior changes based on the sonar values

Loops/Recursion (15 points):

* [ 10 / 10 ] Implements indefinite execusing using at least one while loop OR at least one recursive function call
* [ 5 / 5 ] There is an option to terminate your indefinite execution

